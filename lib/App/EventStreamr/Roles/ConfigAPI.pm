package App::EventStreamr::Roles::ConfigAPI;

use v5.010;
use strict;
use warnings;
use Config::JSON;
use JSON;
use Method::Signatures 20140224; # libmethod-signatures-perl
use HTTP::Tiny; # libhttp-tiny-perl
use Proc::ProcessTable; # libproc-processtable-perl

use Moo::Role; # libmoo-perl

# ABSTRACT: A config api

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

This is a role wraps around the 'run_stop' of a process.

=head1 DESCRIPTION

This is a Role that can be consumed to post config to the internal
and controller APIs.

It requires a 'run_stop' method, so really should only be consumed
by L<App::EventStreamr::Config.

=cut

requires 'write_config','localconfig','config_path','macaddress';

has 'controller_config' => ( is => 'ro', lazy => 1, builder => 1 );
has 'controller'        => ( is => 'rw', lazy => 1, builder => 1 );
has 'remote_config'     => ( is => 'rw', lazy => 1, builder => 1 );
has 'http'              => ( is => 'rw', lazy => 1, builder => 1, handles => [ qw( post get ) ] );

method _build_http() {
  return HTTP::Tiny->new(timeout => 15);
}

method _build_controller_config() {
  return $self->config_path."/controller.json";
}

method _build_controller() {
  if ( -e $self->controller_config ) {
    return Config::JSON->new($self->controller_config)->config->{controller};
  } else {
    return 0;
  }
}

method _build_remote_config() {
  return 0 if (! $self->controller);

  my $response = $self->http->post($self->controller."/api/station/".$self->macaddress);

  # Controller responds with created 201, post our config 
  if ($response->{status} == 201) {
    # Status Post Data
    my $json = to_json($self->localconfig->{config});
    my %headers = (
          'station-mgr' => 1,
          'Content-Type' => 'application/json',
    );
    my %post_data = (
          content => $json,
          headers => \%headers,
    );
  
    $response = $self->http->post($self->controller."/api/station", \%post_data);
  }

  if ($response->{status} == 200 ) {
    my $content = from_json($response->{content});
    if (defined $content && $content ne 'true') {
      return $content->{settings};
    }
    return 0;
  } else {
    return 0;
  }
}

# Although this works, it's rather horrible. We really should
# use the accessors properly and we wouldn't have to ignore
# them and do this (I'll however settle for working first up).
after '_load_config' => sub {
  my $self = shift;
  
  if ( $self->remote_config ) {
    # Eww code duplication of _load_config. Same applies.
    foreach my $key (keys %{$self->{remote_config}}) {
      $self->{$key} = $self->{remote_config}{$key};
    }
    $self->write_config();
  }
};

1;
